lib SceneCulling {
    properties {
        uint    NumDrawCalls;
        uint    MaxMeshEntryIndex;
        bool    CullNearZ;
    }
    
    resources {
        StructuredBuffer DrawCalls {
            swizzle = DrawCall;
        }
        
        RWBuffer VisibleIndexes {
            swizzle = uint;
        }
        
        StructuredBuffer SliceInfos {
            swizzle = CSMSliceInfos;
        }
        
        Buffer CulledIndexes {
            swizzle = uint;
        }

        RWBuffer BatchedModelMatrices {
            swizzle = float4;
        }
        
        StructuredBuffer ShadowCasters {
            swizzle = GPUShadowBatchInfos;
        };
        
        RWByteAddressBuffer DrawArgsBuffer {
            format = uint;
        }
    }
    
    shared {
        groupshared uint g_InstanceBufferOffset[4];
        groupshared uint g_MeshEntryCount[4][1024];
        
        // Checks if the bounding sphere of a draw call intersects with the view frustum
        static bool IsVisible( in DrawCall drawCall, in CSMSliceInfos csmSliceInfos ) {
            bool inFrustum = true;

            [unroll]
            for( uint i = 0; i < 5; ++i ) {
                float d = dot( csmSliceInfos.CascadePlanes[i], float4( drawCall.SphereCenter, 1.0f ) );
                inFrustum = inFrustum && ( d >= -drawCall.SphereRadius );
            }

            if ( CullNearZ ) {
                float d = dot( csmSliceInfos.CascadePlanes[5], float4( drawCall.SphereCenter, 1.0f ) );
                inFrustum = inFrustum && ( d >= -drawCall.SphereRadius );
            }

            return inFrustum;
        }
    }
    
    shader ClearArgsBufferCS {
        // TODO 1024 should be RenderWorld::MAX_MODEL_COUNT
        for ( int i = 0; i < 1024 * 4; i++ ) {
            int offset = i * 20;
            
            DrawArgsBuffer.Store4(offset, uint4(0, 0, 0, 0));
            DrawArgsBuffer.Store(offset + 16, 0);
        }
    }

    shader FrustumCullCS {
        const uint drawIdx = $SV_DispatchThreadId.x;
        if ( drawIdx >= NumDrawCalls ) {
            return;
        }
        
        CSMSliceInfos cascadeInfos = SliceInfos[$SV_GroupThreadID.y];
        DrawCall drawCall = DrawCalls[drawIdx];
        
        uint dstIndex = drawIdx + $SV_GroupThreadID.y * 4096;
        if ( IsVisible( drawCall, cascadeInfos ) ) {
            VisibleIndexes[dstIndex] = ( drawCall.MeshEntryIndex + 1 );
        } else {
            VisibleIndexes[dstIndex] = 0;
        }
    }
    
    shader BatchCommandsCS {
        const uint cascadeIdx = $SV_DispatchThreadId.y;
        
        if ( $SV_DispatchThreadId.x == 0 ) {
            g_InstanceBufferOffset[cascadeIdx] = 0u;
            
            for ( uint i = 0; i < 1024; i++ ) {
                g_MeshEntryCount[cascadeIdx][i] = 0u;
            }
        }
        GroupMemoryBarrierWithGroupSync();
        
        const uint ThreadOffset = cascadeIdx * 4096;
        const uint drawIdx = $SV_DispatchThreadId.x + ThreadOffset;
        
        uint index = CulledIndexes[drawIdx];
        
        if ( index == 0 ) {
            return;
        }
        
        // Update batch instance count.
        InterlockedAdd( g_MeshEntryCount[cascadeIdx][(index - 1)], 1 );
        
        // Store model matrix.
        InterlockedAdd( g_InstanceBufferOffset[cascadeIdx], 1 );
        
        uint instanceBufferCascadeOffset = cascadeIdx * 4 * 1024;
        const uint instanceBufferOffset = ( g_InstanceBufferOffset[cascadeIdx] - 1 ) * 4 + instanceBufferCascadeOffset;
        
        DrawCall drawCall = DrawCalls[$SV_DispatchThreadId.x];
        
        [unroll]
        for ( uint j = 0; j < 4; j++ ) {
            BatchedModelMatrices[instanceBufferOffset + j] = drawCall.ModelMatrix[j]; 
        }
        
        // TODO Try to map one caster idx per thread; check if there is one instance. If that's the case, we atomically increment the group shared offset.
        if ( $SV_DispatchThreadId.x == 0 ) {
            // Compute slice offset (in bytes).
            uint indirectArgsOffset = cascadeIdx * 4 * 1024;
            for ( uint i = 0; i < MaxMeshEntryIndex; i++ ) {
                uint instanceCount = g_MeshEntryCount[cascadeIdx][i];
                if ( instanceCount != 0u ) {
                    GPUShadowBatchInfos caster = ShadowCasters[i];
                    
                    uint4 packedDrawArgs = uint4( caster.IndiceBufferCount, instanceCount, caster.IndiceBufferOffset, caster.VertexBufferOffset );
                    DrawArgsBuffer.Store4( indirectArgsOffset, packedDrawArgs );
                    
                    // Note that we implicitly skip StartInstanceLocation since we don't use it.
                    indirectArgsOffset += 20u;
                }
            }
        }
    }
 
    pass ClearArgsBuffer {
        compute       = ClearArgsBufferCS;
        dispatch      = { 1, 1, 1 };
    }
    
    pass FrustumCullDrawCalls {
        compute       = FrustumCullCS;
        dispatch      = { 128, 4, 1 };
    }
    
    pass BatchCulledCommands {
        compute       = BatchCommandsCS;
        dispatch      = { 128, 4, 1 };
    }
}
