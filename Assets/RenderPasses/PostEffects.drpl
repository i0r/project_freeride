lib PostEffects { 
    properties {
        float BloomStrength = 0.0005f;
        cflag ApplyDither = true;
        cflag EnableBloom = true;
        cflag EnableColorCorrection = true;
        cflag EnableVignette = false;
    }
    
    resources {
        Texture3D ColorGradingLUT {
            swizzle = float4;
        }

        Texture2D InputRenderTarget {
            swizzle = float4;
        }

        Texture2D GlareRenderTarget {
            swizzle = float4;
        }
        
        RWTexture2D OutputRenderTarget {
            swizzle = float4;
        }

        StructuredBuffer AutoExposureBuffer {
            swizzle = AutoExposureInfos;
        }
        
        sampler VolumetricLUTSampler {
            format = BilinearClampEdge;
        }
    }
    
    shared {
        #include <AutoExposure/Shared.hlsli>
        #include <Photometry.hlsli>
        #include <ColorSpaces.hlsli>
        
        float3 InterleavedGradientNoise( float2 uv ) {
            const float3 magic = float3( 0.06711056, 0.00583715, 52.9829189 );
            return frac( magic.z * frac( dot( uv, magic.xy ) ) );
        }

        float3 ComputeBloomLuminance( float3 bloomColor, float bloomEC, float currentEV ) {
            // currentEV is the value calculated at the previous frame
            float bloomEV = currentEV + bloomEC;

            // convert to luminance
            // See equation (12) for explanation about converting EV to luminance
            return bloomColor * pow( 2, bloomEV - 3 );
        }
                
        float ApplyVignette( in float2 texCoord ) {
            return ( 0.3 + 0.7 * pow(16.0 * texCoord.x * texCoord.y * (1.0 - texCoord.x) * (1.0 - texCoord.y), 0.2));
        }

        float3 LUTlookup(in float3 InputColor, in Texture3D LUT) {
            static const float3 Scale = 15.0f / 16.0f;
            static const float3 Offset = 1.0f / 32.0f;
            
            float3 TexCoords = Scale * InputColor + Offset;
            
            float4 CorrectedColor = LUT.SampleLevel( VolumetricLUTSampler, TexCoords, 0.0f );
            return CorrectedColor.rgb;
        }
    }
    
    shader FinalPass {
        AutoExposureInfos currentExposure = AutoExposureBuffer[0];
        float currentEV = computeEV100FromAvgLuminance( currentExposure.EngineLuminanceFactor );       
        float exposure = exp2( ( convertEV100ToExposure( currentEV ) ) );
        
        float2 texCoords = float2( $SV_DispatchThreadId.xy ) / g_ScreenSize;
        float4 finalColor = InputRenderTarget.Load( $SV_DispatchThreadId );
        
        if ( $EnableBloom ) {
            float3 glareColor = GlareRenderTarget.Load( $SV_DispatchThreadId );
            float3 glareLuminance = ComputeBloomLuminance( glareColor, 0.0f, currentEV );
            finalColor.rgb = lerp( finalColor.rgb, glareLuminance, BloomStrength );            
        }
    
        if ( $EnableVignette ) {
            finalColor.rgb *= ApplyVignette( texCoords );
        }
        
        float3 color = ACESFilmic( finalColor.rgb * exposure );
        color = accurateLinearToSRGB( color );
        
        if ( $EnableColorCorrection ) {
            color = LUTlookup( color, ColorGradingLUT );
        }

        if ( $ApplyDither ) {
            // Add a dithering pattern to attenuate color banding
            float3 rnd = InterleavedGradientNoise( float2( $SV_DispatchThreadId.xy ) ) / 255.0f;
            color.rgb += rnd;
        }
    
        OutputRenderTarget[$SV_DispatchThreadId.xy] = float4( color, 1.0f );
    }
    
    pass Default {
        compute       = FinalPass;        
        dispatch      = { 16, 16, 1 };
    }
}
