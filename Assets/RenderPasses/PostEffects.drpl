lib PostEffects { 
    properties {
        float BloomStrength = 0.0005f;
        cflag ApplyDither = true;
        cflag EnableBloom = true;
        cflag EnableColorCorrection = true;
    }
    
    resources {
        Texture2D ColorGradingLUT {
            swizzle = float4;
        }

        Texture2D InputRenderTarget {
            swizzle = float4;
        }

        Texture2D GlareRenderTarget {
            swizzle = float4;
        }
        
        RWTexture2D OutputRenderTarget {
            swizzle = float4;
        }

        StructuredBuffer AutoExposureBuffer {
            swizzle = AutoExposureInfos;
        }
    }
    
    shared {
        #include <AutoExposure/Shared.hlsli>
        #include <Photometry.hlsli>
        #include <ColorSpaces.hlsli>
        
        float3 InterleavedGradientNoise( float2 uv ) {
            const float3 magic = float3( 0.06711056, 0.00583715, 52.9829189 );
            return frac( magic.z * frac( dot( uv, magic.xy ) ) );
        }

        float3 ComputeBloomLuminance( float3 bloomColor, float bloomEC, float currentEV ) {
            // currentEV is the value calculated at the previous frame
            float bloomEV = currentEV + bloomEC;

            // convert to luminance
            // See equation (12) for explanation about converting EV to luminance
            return bloomColor * pow( 2, bloomEV - 3 );
        }
        
        float3 ApplyColorCorrection( float3 inputColor, Texture2D colorCorrectionLUT) {
            float BlueColor = inputColor.b * 63.0f;
            
            float BlueFloor = floor( BlueColor );
            float BlueCeil = ceil( BlueColor );
            
            float QuadFloorY = floor( BlueFloor / 8.0f );
            float QuadCeilY = floor( BlueCeil / 8.0f );
            
            float4 Quad = float4( BlueFloor - QuadFloorY * 8.0f, QuadFloorY, BlueCeil - QuadCeilY * 8.0f, QuadCeilY );
            float4 TexCoords = float4( 
                ( Quad.x * 0.125f ) + 0.5f / 512.0f + ( ( 0.125f - 1.0f / 512.0f ) * inputColor.r ),
                ( Quad.y * 0.125f ) + 0.5f / 512.0f + ( ( 0.125f - 1.0f / 512.0f ) * inputColor.g ),
                ( Quad.z * 0.125f ) + 0.5f / 512.0f + ( ( 0.125f - 1.0f / 512.0f ) * inputColor.r ),
                ( Quad.w * 0.125f ) + 0.5f / 512.0f + ( ( 0.125f - 1.0f / 512.0f ) * inputColor.g )
            );
            
            float4 CorrectedColorLow = colorCorrectionLUT[TexCoords.xy];
            float4 CorrectedColorHigh = colorCorrectionLUT[TexCoords.zw];
            float CorrectionInterp = frac( BlueColor );
            
            return lerp( CorrectedColorLow, CorrectedColorHigh, CorrectionInterp );
        }
    }
    
    shader FinalPass {
        AutoExposureInfos currentExposure = AutoExposureBuffer[0];
        float currentEV = computeEV100FromAvgLuminance( currentExposure.EngineLuminanceFactor );       
        float exposure = exp2( ( convertEV100ToExposure( currentEV ) ) );
        
        float4 finalColor = InputRenderTarget.Load( $SV_DispatchThreadId );
        
        if ( $EnableBloom ) {
            float3 glareColor = GlareRenderTarget.Load( $SV_DispatchThreadId );
            float3 glareLuminance = ComputeBloomLuminance( glareColor, 0.0f, currentEV );
            finalColor.rgb = lerp( finalColor.rgb, glareLuminance, BloomStrength );            
        }
    
        float3 color = ACESFilmic( finalColor.rgb * exposure );    
        color = accurateLinearToSRGB( color );

        if ( $EnableColorCorrection ) {
            color = ApplyColorCorrection( color, ColorGradingLUT );
        }

        if ( $ApplyDither ) {
            // Add a dithering pattern to attenuate color banding
            float3 rnd = InterleavedGradientNoise( float2( $SV_DispatchThreadId.xy ) ) / 255.0f;
            color.rgb += rnd;
        }
    
        OutputRenderTarget[$SV_DispatchThreadId.xy] = float4( color, 1.0f );
    }
    
    pass Default {
        compute       = FinalPass;        
        dispatch      = { 16, 16, 1 };
    }
}
