lib BrdfLut {
    properties {
        cint    SAMPLE_COUNT = 2048;
        cint    MipCount = 6;
        float   Roughness;
        float   Width;
        uint    CubeFace;
    }
    
    resources {
        RWTexture2D ComputedLUT {
            swizzle = float2;
        } 
        
        RWTexture2D IBLDiffuseOutput {
            swizzle = float4;
        }
        
        RWTexture2D IBLSpecularOutput {
            swizzle = float4;
        }
        
        TextureCube EnvironmentCube {
            swizzle = float4;
        }
        
        sampler TrilinearSampler {
            format = TrilinearClampEdge;
        }        
    }
    
    shared {
        float RadicalInverse_VdC(uint bits)
        {
            bits = (bits << 16u) | (bits >> 16u);
            bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
            bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
            bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
            bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
            return float(bits) * 2.3283064365386963e-10; // / 0x100000000
        }
        
        float2 Hammersley(uint i, uint N)
        {
            return float2(float(i) / float(N), RadicalInverse_VdC(i));
        }
        
        float DistributionGGX(float3 N, float3 H, float roughness)
        {
            float a = roughness * roughness;
            //float a = pow(((roughness + 1) / 2), 2);
            float a2 = a * a;
            float NdotH = max(dot(N, H), 0.0);
            float NdotH2 = NdotH * NdotH;

            float nom = a2;
            float denom = (NdotH2 * (a2 - 1.0) + 1.0);
            denom = PI * denom * denom;

            return nom / denom;
        }
        
        float3 ImportanceSampleGGX(float2 Xi, float3 N, float roughness)
        {
            float a = roughness * roughness;
            
            float phi = 2.0 * PI * Xi.x;
            float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));
            float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
            
            // from spherical coordinates to cartesian coordinates - halfway vector
            float3 H;
            H.x = cos(phi) * sinTheta;
            H.y = sin(phi) * sinTheta;
            H.z = cosTheta;
            
            // from tangent-space H vector to world-space sample vector
            float3 up = abs(N.z) < 0.999 ? float3(0.0, 0.0, 1.0) : float3(1.0, 0.0, 0.0);
            float3 tangent = normalize(cross(up, N));
            float3 bitangent = cross(N, tangent);
            
            return tangent * H.x + bitangent * H.y + N * H.z;
        }
        
        float GeometrySchlickGGX(float NoV, float roughness)
        {
            // note that we use a different k for IBL
            float a = roughness;
            float k = (a * a) / 2.0;

            float nom = NoV;
            float denom = NoV * (1.0 - k) + k;

            return nom / denom;
        }
        
        float GeometrySmith(float3 N, float3 V, float3 L, float roughness)
        {
            float NoV = max(dot(N, V), 0.0);
            float NdotL = max(dot(N, L), 0.0);
            float ggx2 = GeometrySchlickGGX(NoV, roughness);
            float ggx1 = GeometrySchlickGGX(NdotL, roughness);

            return ggx1 * ggx2;
        }
    
        float3 ThreadIDToDir(uint2 cubeCoord, uint cubeFace, float2 cubemapSize)
        {
            float2 texCoord = float2( cubeCoord ) / cubemapSize;
            texCoord = texCoord * 2.0f - 1.0f;

            switch(cubeFace)
            {
              case (0): return float3(1.0f, -texCoord.yx);
              case (1): return float3(-1.0f, -texCoord.y, texCoord.x);
              case (2): return float3(texCoord.x, 1.0f, texCoord.y);
              case (3): return float3(texCoord.x, -1.0f, -texCoord.y);
              case (4): return float3(texCoord.x, -texCoord.y, 1.0f);
              case (5): return float3(-texCoord.xy, -1.0f);
            }
            return float3(0.0f, 0.0f, 0.0f);
        }
                
        void importanceSampleCosDir(
            in float2 u,
            in float3 N,
            out float3 L,
            out float NdotL,
            out float pdf )
        {
            // Local referencial
            float3 upVector = abs( N.z ) < 0.999 ? float3( 0, 0, 1 ) : float3( 1, 0, 0 );
            float3 tangentX = normalize( cross( upVector, N ) );
            float3 tangentY = cross( N, tangentX );

            float u1 = u.x;
            float u2 = u.y;

            float r = sqrt( u1 );
            float phi = u2 * PI * 2;

            L = float3( r*cos( phi ), r*sin( phi ), sqrt( max( 0.0f, 1.0f - u1 ) ) );
            L = normalize( tangentX * L.y + tangentY * L.x + N * L.z );

            NdotL = dot( L, N );
            pdf = NdotL * INV_PI;
        }

        float D_GGX( float NdotH, float m )
        {
            // Divide by PI is apply later
            float m2 = m * m;
            float f = ( NdotH * m2 - NdotH ) * NdotH + 1;
            return m2 / ( f * f );
        }

        float D_GGX_Divide_Pi( float NdotH, float roughness )
        {
            return D_GGX( NdotH, roughness ) / PI;
        }
        
        struct Referential
        {
            float3 upVector;
            float3 tangentX;
            float3 tangentY;
        };

        Referential CreateReferential( in float3 N )
        {
            Referential referential;
            referential.upVector = abs( N.z ) < 0.999 ? float3( 0, 0, 1 ) : float3( 1, 0, 0 );
            referential.tangentX = normalize( cross( referential.upVector, N ) );
            referential.tangentY = cross( N, referential.tangentX );
            return referential;
        }
        
        float3 ImportanceSampleGGX( float2 Xi, float Roughness, float3 N, Referential referential )
        {
            float a = Roughness * Roughness;
            float Phi = 2 * PI * Xi.x;
            float CosTheta = sqrt( ( 1 - Xi.y ) / ( 1 + ( a*a - 1 ) * Xi.y ) );
            float SinTheta = sqrt( 1 - CosTheta * CosTheta );
            float3 H;
            H.x = SinTheta * cos( Phi );
            H.y = SinTheta * sin( Phi );
            H.z = CosTheta;
            // Tangent to world space
            return referential.tangentX * H.x + referential.tangentY * H.y + N * H.z;
        }

        void ImportanceSampleGGXDir( in float2 Xi, in float3 V, in float3 N, in float Roughness, out float3 H, out float3 L )
        {
            Referential referential = CreateReferential( N );
            H = ImportanceSampleGGX( Xi, Roughness, N, referential );
            L = 2 * dot( V, H ) * H - V;
        }

        float4 IntegrateDiffuseCube( in float3 N )
        {
            float3 accBrdf = float3( 0, 0, 0 );

            for ( uint i = 0; i < $SAMPLE_COUNT; ++i ) {
                float2 eta = Hammersley( i, $SAMPLE_COUNT );

                float3 L;
                float NdotL;
                float pdf;

                // see reference code in appendix
                importanceSampleCosDir( eta, N, L, NdotL, pdf );

                if ( NdotL > 0 ) {
                    accBrdf += EnvironmentCube.SampleLevel( TrilinearSampler, L, 0 ).rgb;
                }
            }

            return float4 ( accBrdf * ( 1.0f / $SAMPLE_COUNT ), 1.0f );
        }
        
        float4 IntegrateCubeLDOnly( in float3 V, in float3 N, in float roughness )
        {
            float3 accBrdf = float3( 0, 0, 0 );
            float accBrdfWeight = 0;
            for ( uint i = 0; i< $SAMPLE_COUNT; ++i ) {
                float2 eta = Hammersley( i, $SAMPLE_COUNT );
                float3 L;
                float3 H;
                ImportanceSampleGGXDir( eta, V, N, roughness, H, L );
                float NdotL = dot( N, L );
                if ( NdotL > 0 ) {                   
                    float mipLevel = 0;
                    float NdotH = saturate( dot( N, H ) );
                    float LdotH = saturate( dot( L, H ) );
                    float pdf = D_GGX_Divide_Pi( NdotH, roughness ) * NdotH / ( 4 * LdotH );
                    if ( pdf > 0.0 ) {
                        float omegaS = 1.0 / ( $SAMPLE_COUNT * pdf );
                        float omegaP = 4.0 * PI / ( 6.0 * Width * Width );
                        float mipLevel = clamp( 0.5 * log2( omegaS / omegaP ), 0, $MipCount );

                        mipLevel = clamp( 0.5 * log2( omegaS / omegaP ), 0, $MipCount );
                    }

                    float4 Li = EnvironmentCube.SampleLevel( TrilinearSampler, L, mipLevel ); 
                    
                    accBrdf += Li.rgb * NdotL;
                    accBrdfWeight += NdotL;
                }
            }

            return float4( accBrdf * ( 1.0f / accBrdfWeight ), 1.0f );
        }
        
        // Based on Karis 2014
        float3 importanceSampleGGX(float2 Xi, float roughness, float3 N)
        {
            float a = roughness * roughness;
            
            // Sample in spherical coordinates
            float phi = 2.0 * PI * Xi.x;
            float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));
            float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
            
            // Construct tangent space vector
            float3 H = float3(
                sinTheta * cos(phi),
                sinTheta * sin(phi),
                cosTheta
            );
            
            // Tangent to world space
            float3 upVector = abs(N.z) < 0.999 ? float3(0.0, 0.0, 1.0) : float3(1.0, 0.0, 0.0);
            float3 tangentX = normalize(cross(upVector, N));
            float3 tangentY = normalize(cross(N, tangentX));
            
            // Convert to world Space
            return normalize(tangentX * H.x + tangentY * H.y + N * H.z);
        }
        
        // From the filament docs. Geometric Shadowing function
        // https://google.github.io/filament/Filament.html#toc4.4.2
        float V_SmithGGXCorrelated(float NoV, float NoL, float roughness) {
            float a2 = pow(roughness, 4.0);
            float GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);
            float GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);
            return ( 0.5f / (GGXV + GGXL));
        }
        
        // Karis 2014
        float2 IntegrateBRDF(float roughness, float NoV)
        {
            float3 V;
            V.x = sqrt(1.0 - NoV * NoV); // sin
            V.y = 0.0;
            V.z = NoV; // cos

            // N points straight upwards for this integration
            const float3 N = float3(0.0, 0.0, 1.0);

            float A = 0.0;
            float B = 0.0;
            const uint numSamples = 1024;

            for (uint i = 0u; i < numSamples; i++) {
                float2 Xi = Hammersley(i, numSamples);
                // Sample microfacet direction
                float3 H = importanceSampleGGX(Xi, roughness, N);

                // Get the light direction
                float3 L = 2.0 * dot(V, H) * H - V;

                float NoL = saturate(dot(N, L));
                float NoH = saturate(dot(N, H));
                float VoH = saturate(dot(V, H));

                if (NoL > 0.0) {
                    // Terms besides V are from the GGX PDF we're dividing by
                    float V_pdf = V_SmithGGXCorrelated(NoV, NoL, roughness) * VoH * NoL / NoH;
                    float Fc = pow(1.0 - VoH, 5.0);
                    A += (1.0 - Fc) * V_pdf;
                    B += Fc * V_pdf;
                }
            }

            return ( 4.0 * float2(A, B) / float(numSamples) );
        }
    }
    
    shader MSLutPrecompute {
        uint2 texelPos = $SV_DispatchThreadID.xy;
        
        float2 uvCoords = ( float2( texelPos ) + 0.5f ) / float(BRDF_LUT_SIZE);
        float NoV = uvCoords.x;
        float roughness = max(0.045f, uvCoords.y );
        
        float2 result = IntegrateBRDF(roughness, NoV);
        ComputedLUT[texelPos] = result;
    }
    
    shader ConvoluteCubeFaceCS {
        uint2 texelPos = $SV_DispatchThreadID.xy;
        float3 dir = ThreadIDToDir( texelPos, CubeFace, float2( Width, Width ) );
        
        IBLDiffuseOutput[texelPos.xy] = IntegrateDiffuseCube( dir );
        IBLSpecularOutput[texelPos.xy] = IntegrateCubeLDOnly( dir, dir, Roughness );
    }
    
    pass ComputeBRDFLut {
        compute       = MSLutPrecompute;       
        dispatch      = { 16, 16, 1 };
    }    
    
    pass ConvoluteCubeFace {
        compute       = ConvoluteCubeFaceCS;       
        dispatch      = { 16, 16, 1 };
    }
}
