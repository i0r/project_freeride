lib AtmosphereLUTCompute { 
    properties {
        AtmosphereParameters        AtmosphereParams;
    }
    
    resources {
        RWTexture2D OutputRenderTarget {
            swizzle = float4;
        }
        
        Texture2D TransmittanceTexture {
            swizzle = float4;
        }
    }
    
    shared {
        #include <AtmosphereFunctions.hlsli>
        
        Length ComputeOpticalLengthToTopAtmosphereBoundary(AtmosphereParameters atmosphere, DensityProfile profile, Length r, Number mu) 
        {
            static const int SAMPLE_COUNT = 500;
            Length dx = DistanceToTopAtmosphereBoundary(atmosphere, r, mu) / Number(SAMPLE_COUNT);
            Length result = 0.0 * m;

            for (int i = 0; i <= SAMPLE_COUNT; ++i) {
                Length d_i = Number(i) * dx;
                Length r_i = sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r);
                Number y_i = GetProfileDensity(profile, r_i - atmosphere.bottom_radius);
                Number weight_i = i == 0 || i == SAMPLE_COUNT ? 0.5 : 1.0;
                result += y_i * weight_i * dx;
            }

            return result;
        }

        DimensionlessSpectrum ComputeTransmittanceToTopAtmosphereBoundary(AtmosphereParameters atmosphere, Length r, Number mu) 
        {
            return exp(-(
              atmosphere.rayleigh_scattering *
                  ComputeOpticalLengthToTopAtmosphereBoundary(
                      atmosphere, atmosphere.rayleigh_density, r, mu) +
              atmosphere.mie_extinction *
                  ComputeOpticalLengthToTopAtmosphereBoundary(
                      atmosphere, atmosphere.mie_density, r, mu) +
              atmosphere.absorption_extinction *
                  ComputeOpticalLengthToTopAtmosphereBoundary(
                      atmosphere, atmosphere.absorption_density, r, mu)));
        }
        
        void GetRMuFromTransmittanceTextureUv(AtmosphereParameters atmosphere, float2 uv, inout Length r, inout Number mu) 
        {
            Number x_mu = GetUnitRangeFromTextureCoord(uv.x, TRANSMITTANCE_TEXTURE_WIDTH);
            Number x_r = GetUnitRangeFromTextureCoord(uv.y, TRANSMITTANCE_TEXTURE_HEIGHT);
            Length H = sqrt(atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius);
            Length rho = H * x_r;
            r = sqrt(rho * rho + atmosphere.bottom_radius * atmosphere.bottom_radius);
            Length d_min = atmosphere.top_radius - r;
            Length d_max = rho + H;
            Length d = d_min + x_mu * (d_max - d_min);
            mu = d == 0.0 * m ? Number(1.0) : (H * H - rho * rho - d * d) / (2.0 * r * d);
            mu = ClampCosine(mu);
        }
        
        DimensionlessSpectrum ComputeTransmittanceToTopAtmosphereBoundaryTexture(AtmosphereParameters atmosphere, float2 frag_coord) 
        {
            static const float2 TRANSMITTANCE_TEXTURE_SIZE = float2(TRANSMITTANCE_TEXTURE_WIDTH, TRANSMITTANCE_TEXTURE_HEIGHT);
            
            Length r;
            Number mu;
            GetRMuFromTransmittanceTextureUv(atmosphere, frag_coord / TRANSMITTANCE_TEXTURE_SIZE, r, mu);
            
            return ComputeTransmittanceToTopAtmosphereBoundary(atmosphere, r, mu);
        }
    }
    
    shader ComputeTransmittanceCS {
        float3 Transmittance = ComputeTransmittanceToTopAtmosphereBoundaryTexture( AtmosphereParams, float2( $SV_DispatchThreadId.xy ) );
        OutputRenderTarget[$SV_DispatchThreadId.xy] = float4( Transmittance, 1.0f );
    }
    
    shader ComputeDirectIrradianceCS {
        OutputRenderTarget[$SV_DispatchThreadId.xy] = float4( ComputeDirectIrradianceTexture( AtmosphereParams, TransmittanceTexture, $SV_DispatchThreadId.xy ), 1.0f );
    }
    
    pass ComputeTransmittance {
        compute       = ComputeTransmittanceCS;        
        dispatch      = { 16, 8, 1 };
    }
    
    pass ComputeDirectIrradiance {    
        compute       = ComputeDirectIrradianceCS;        
        dispatch      = { 16, 8, 1 };
    }
}
