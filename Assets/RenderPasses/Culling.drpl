lib Culling {
    properties {
        cflag CullBackface = false;
    }
    
    resources {
        RWBuffer IndirectArgs {
            swizzle = uint;
        }
        
        RWBuffer FilteredIndiceBuffer {
            swizzle = uint;
        }
        
        ByteAddressBuffer VertexBuffer {
            format = uint;
        }
        
        Buffer IndexBuffer {
            swizzle = uint;
        }
        
        StructuredBuffer MeshConstantsBuffer {
            swizzle = MeshConstants;
        }
        
        StructuredBuffer DrawConstants {
            swizzle = SmallBatchDrawConstants;
        }
        
        StructuredBuffer SmallBatchDataBuffer {
            swizzle = SmallBatchData;
        }
    }
    
    shared { 
        groupshared uint g_WorkGroupOutputSlot;
        groupshared uint g_WorkGroupIndexCount;
        
        float3 LoadVertex(uint index, uint vertexOffset) {
            return asfloat(VertexBuffer.Load3(vertexOffset + index * 12));
        }
                
        bool CullTriangle( uint indices[3], float4 vertices[3] ) {
            bool cull = false;

            if ( indices[0] == indices[1] 
                || indices[1] == indices[2]
                || indices[0] == indices[2] ) {
                cull = true;
            }

            // Culling in homogenous coordinates
            // Read: "Triangle Scan Conversion using 2D Homogeneous Coordinates"
            //       by Marc Olano, Trey Greer
            //       http://www.cs.unc.edu/~olano/papers/2dh-tri/2dh-tri.pdf
            float3x3 m = {
                vertices[0].xyw, 
                vertices[1].xyw, 
                vertices[2].xyw
            };

#ifdef $CullBackface
            cull = cull || ( determinant( m ) > 0 );
#else
            cull = cull || ( determinant( m ) <= 0 );      
#endif

            int verticesInFrontOfNearPlane = 0;

            // Transform vertices[i].xy into normalized 0..1 screen space
            for ( uint i = 0; i < 3; ++i ) {
                vertices[i].xy /= vertices[i].w;
                vertices[i].xy /= 2;
                vertices[i].xy += float2( 0.5f, 0.5f );
                if ( vertices[i].w < 0 ) {
                    ++verticesInFrontOfNearPlane;
                }
            }

            static const uint SUBPIXEL_BITS = 8;
            static const uint SUBPIXEL_MASK = 0xFF;
            static const uint SUBPIXEL_SAMPLES = 1 << SUBPIXEL_BITS;

            int2 minBB = int2( 1 << 30, 1 << 30 );
            int2 maxBB = int2( -( 1 << 30 ), -( 1 << 30 ) );

            bool insideGuardBand = true;
            for ( uint i = 0; i < 3; ++i ) {
                float2 screenSpacePositionFP = vertices[i].xy * g_ScreenSize;
                
                // Check if we would overflow after conversion
                if (   screenSpacePositionFP.x < -(1 << 23)
                    || screenSpacePositionFP.x >  (1 << 23)
                    || screenSpacePositionFP.y < -(1 << 23)
                    || screenSpacePositionFP.y >  (1 << 23) ) {
                    insideGuardBand = false;
                }

                int2 screenSpacePosition = int2( screenSpacePositionFP * SUBPIXEL_SAMPLES );
                minBB = min( screenSpacePosition, minBB );
                maxBB = max( screenSpacePosition, maxBB );
            }

            if (verticesInFrontOfNearPlane == 0 && insideGuardBand) {
                /**
                Test is:

                Is the minimum of the bounding box right or above the sample
                point and is the width less than the pixel width in samples in
                one direction.

                This will also cull very long triangles which fall between
                multiple samples.
                */
                cull = cull
                || (
                        ((minBB.x & SUBPIXEL_MASK) > SUBPIXEL_SAMPLES/2)
                    &&  ((maxBB.x - ((minBB.x & ~SUBPIXEL_MASK) + SUBPIXEL_SAMPLES/2)) < (SUBPIXEL_SAMPLES - 1)))
                || (
                        ((minBB.y & SUBPIXEL_MASK) > SUBPIXEL_SAMPLES/2)
                    &&  ((maxBB.y - ((minBB.y & ~SUBPIXEL_MASK) + SUBPIXEL_SAMPLES/2)) < (SUBPIXEL_SAMPLES - 1)));
            }
            
            if (verticesInFrontOfNearPlane == 3) {
                cull = true;
            }

            if (verticesInFrontOfNearPlane == 0) {
                float minx = min (min (vertices[0].x, vertices[1].x), vertices[2].x);
                float miny = min (min (vertices[0].y, vertices[1].y), vertices[2].y);
                float maxx = max (max (vertices[0].x, vertices[1].x), vertices[2].x);
                float maxy = max (max (vertices[0].y, vertices[1].y), vertices[2].y);

                cull = cull || (maxx < 0) || (maxy < 0) || (minx > 1) || (miny > 1);
            }
            
            return cull;
        }
    }
    
    shader ClearArgsBufferCS {
        IndirectArgs[$SV_DispatchThreadID.x * 5 + 0] = 0;
    }

    shader FilterGeometryCS {
        if ( $SV_GroupThreadID.x == 0 ) {
            g_WorkGroupIndexCount = 0;
        }

        GroupMemoryBarrierWithGroupSync();

        bool cull = true;
        uint threadOutputSlot = 0;

        uint batchMeshIndex = SmallBatchDataBuffer[$SV_GroupID.x].MeshIndex;
        uint batchInputIndexOffset = ( MeshConstantsBuffer[batchMeshIndex].IndexOffset + SmallBatchDataBuffer[$SV_GroupID.x].IndexOffset ) / 4;
        uint batchInputVertexOffset = MeshConstantsBuffer[batchMeshIndex].VertexOffset;
        uint batchDrawIndex = SmallBatchDataBuffer[$SV_GroupID.x].DrawIndex;
        
        if ($SV_GroupThreadID.x < SmallBatchDataBuffer[$SV_GroupID.x].FaceCount) {
            float4x4 modelMatrix = DrawConstants[batchDrawIndex].ModelMatrix;

            uint indices[3] = {
                IndexBuffer[$SV_GroupThreadID.x * 3 + 0 + batchInputIndexOffset],
                IndexBuffer[$SV_GroupThreadID.x * 3 + 1 + batchInputIndexOffset],
                IndexBuffer[$SV_GroupThreadID.x * 3 + 2 + batchInputIndexOffset]
            };

            float4 vertices[3] = {
                mul( g_ViewProjectionMatrix, mul( float4( LoadVertex( indices[0], batchInputVertexOffset ), 1 ), modelMatrix ) ),
                mul( g_ViewProjectionMatrix, mul( float4( LoadVertex( indices[1], batchInputVertexOffset ), 1 ), modelMatrix ) ),
                mul( g_ViewProjectionMatrix, mul( float4( LoadVertex( indices[2], batchInputVertexOffset ), 1 ), modelMatrix ) )
            };

            cull = false; //CullTriangle( indices, vertices );

            if ( !cull ) {
                InterlockedAdd( g_WorkGroupIndexCount, 3, threadOutputSlot );
            }
        }
        
        GroupMemoryBarrierWithGroupSync();

        if ( $SV_GroupThreadID.x == 0 ) {
            InterlockedAdd( IndirectArgs[batchDrawIndex * 5], g_WorkGroupIndexCount, g_WorkGroupOutputSlot );
        }

        AllMemoryBarrierWithGroupSync();

        uint outputIndexOffset = g_WorkGroupOutputSlot + SmallBatchDataBuffer[$SV_GroupID.x].OutputIndexOffset / 4;

        if ( !cull ) {
            FilteredIndiceBuffer[outputIndexOffset + threadOutputSlot + 0] = IndexBuffer[$SV_GroupThreadID.x * 3 + 0 + batchInputIndexOffset];
            FilteredIndiceBuffer[outputIndexOffset + threadOutputSlot + 1] = IndexBuffer[$SV_GroupThreadID.x * 3 + 1 + batchInputIndexOffset];
            FilteredIndiceBuffer[outputIndexOffset + threadOutputSlot + 2] = IndexBuffer[$SV_GroupThreadID.x * 3 + 2 + batchInputIndexOffset];
        }

        if ( $SV_GroupThreadID.x == 0 && $SV_GroupID.x == SmallBatchDataBuffer[$SV_GroupID.x].DrawBatchStart ) {
            IndirectArgs[batchDrawIndex * 5 + 2] = SmallBatchDataBuffer[$SV_GroupID.x].OutputIndexOffset / 4; // 4 == sizeof (int32)
            IndirectArgs[batchDrawIndex * 5 + 3] = batchInputVertexOffset / 12; // 12 == sizeof (float3)
            IndirectArgs[batchDrawIndex * 5 + 4] = batchDrawIndex;
        }
    }

    pass ClearArgsBuffer {
        compute       = ClearArgsBufferCS;
        dispatch      = { 256, 1, 1 };
    }
    
    pass FilterGeometry {
        compute       = FilterGeometryCS;
        dispatch      = { 256, 1, 1 };
        CullBackface  = true;
    }
    
    pass FilterShadowGeometry {
        compute       = FilterGeometryCS;
        dispatch      = { 256, 1, 1 };
    }
}
