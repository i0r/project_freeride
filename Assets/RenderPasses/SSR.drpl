lib SSR {
    properties {
        uint2 OutputSize;
        float2 HaltonOffset;
    }
    
    resources {
        sampler LinearSampler {
            format = LinearClampEdge;
        }
        
        RWTexture2D RayHitTarget {
            swizzle = float4;
        }
        
        RWTexture2D MaskTarget {
            swizzle = float;
        }
        
        Texture2D HiZDepthBuffer {
            swizzle = float;
        }
        
        Texture2D ThinGBuffer {
            swizzle = float4;
        }
        
        Texture2D BlueNoise {
            swizzle = float2;
        }
        
        // Resolve Pass
        Texture2D ColorBuffer {
            swizzle = float4;
        }
        
        Texture2D RayTraceBuffer {
            swizzle = float4;
        }
        
        Texture2D MaskBuffer {
            swizzle = float;
        }
        
        RWTexture2D ResolvedOutput {
            swizzle = float4;
        }
    }
   
    shared {
        #include <GeometryUtils.hlsli>
        
        static const float Weight[9] = {
            1.0f / 16,
            1.0f / 8,
            1.0f / 16,
            1.0f / 8,
            1.0f / 4,
            1.0f / 8,
            1.0f / 16,
            1.0f / 8,
            1.0f / 16
        };
        
        static const float2 Offset[4] =	
        {	
            float2(0, 0),	
            float2(2, -2),	
            float2(-2, -2),	
            float2(0, 2)	
        };
        
        static const int NUM_STEPS = 300;
        static const float BRDF_BIAS = 0.7f;
        static const float RAY_BIAS = 0.05f;
        static const int HIZ_START_LEVEL = 0;
        static const int HIZ_STOP_LEVEL = 0;
        static const float THICKNESS = 50.0f;
        static const int BLUE_NOISE_SIZE = 1024;
        static const float TEMPORAL_WEIGHT = 0.99f;
        static const float TEMPORAL_CLAMP_SCALE = 3.00f;
        static const float EXPOSURE = 1.0f;
        static const int NUM_RESOLVE = 4;
        static const uint MAX_ITERATIONS = 32;
        static const int HIZ_MAX_LEVEL = 8;
        static const float SSRMaxRoughness = 1.0f;

        inline float SmithJointGGXVisibilityTerm(float NdotL, float NdotV, float roughness)
        {
            float a = roughness;
            float lambdaV = NdotL * (NdotV * (1 - a) + a);
            float lambdaL = NdotV * (NdotL * (1 - a) + a);

            return (0.5f / (lambdaV + lambdaL + 1e-5f));
        }

        inline float GGXTerm(float NdotH, float roughness)
        {
            float a2 = roughness * roughness;
            float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad
            return a2 / (PI * (d * d + 1e-7f)); // This function is not intended to be running on Mobile,
            // therefore epsilon is smaller than what can be represented by float
        }
 
        float BRDF_Weight(float3 V, float3 L, float3 N, float Roughness)
        {
            float3 H = normalize(L + V);

            float NdotH = saturate(dot(N, H));
            float NdotL = saturate(dot(N, L));
            float NdotV = saturate(dot(N, V));

            float G = SmithJointGGXVisibilityTerm(NdotL, NdotV, Roughness);
            float D = GGXTerm(NdotH, Roughness);

            return (D * G) * (PI / 4.0);
        }
        
        float4 ImportanceSampleGGX(float2 Xi, float Roughness) {
            float m = Roughness * Roughness;
            float m2 = m * m;

            float Phi = 2 * PI * Xi.x;

            float CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (m2 - 1.0) * Xi.y));
            float SinTheta = sqrt(max(1e-5, 1.0 - CosTheta * CosTheta));

            float3 H;
            H.x = SinTheta * cos(Phi);
            H.y = SinTheta * sin(Phi);
            H.z = CosTheta;

            float d = (CosTheta * m2 - CosTheta) * CosTheta + 1;
            float D = m2 / (PI * d * d);
            float pdf = D * CosTheta;

            return float4(H, pdf);
        }
        
        float2 CalculateMotion(float2 inUV, float rawDepth)
        {
            float4 worldPos = float4(inUV, rawDepth, 1.0f);

            float4 prevClipPos = mul(worldPos, g_PreviousViewProjectionMatrix);
            float4 curClipPos = mul(worldPos, g_ViewProjectionMatrix);

            float2 prevHPos = prevClipPos.xy / prevClipPos.w;
            float2 curHPos = curClipPos.xy / curClipPos.w;

            // V is the viewport position at this pixel in the range 0 to 1.
            float2 vPosPrev = prevHPos.xy / float2(2.0f, -2.0f) + float2(0.5f, 0.5f);
            float2 vPosCur = curHPos.xy / float2(2.0f, -2.0f) + float2(0.5f, 0.5f);
            return vPosCur - vPosPrev;
        }
        
        void ResolveAABB
        (
            Texture2D currColor,
            float AABBScale,
            float2 uv,
            float2 ScreenSize,
            inout float Variance,
            inout float4 MinColor,
            inout float4 MaxColor,
            inout float4 FilterColor
        )
        {
            const int2 SampleOffset[9] = {
                int2(-1.0, -1.0),
                int2(0.0, -1.0),
                int2(1.0, -1.0),
                int2(-1.0, 0.0),
                int2(0.0, 0.0),
                int2(1.0, 0.0),
                int2(-1.0, 1.0),
                int2(0.0, 1.0),
                int2(1.0, 1.0)
            };

            float4 SampleColors[9];

            for (uint i = 0; i < 9; i++)
            {
                SampleColors[i] = currColor.Load(int3( uv + (SampleOffset[i] / ScreenSize), 0 ) );
            }

            half4 m1 = 0.0;
            half4 m2 = 0.0;
            for (uint x = 0; x < 9; x++)
            {
                m1 += SampleColors[x];
                m2 += SampleColors[x] * SampleColors[x];
            }

            half4 mean = m1 / 9.0;
            half4 stddev = sqrt((m2 / 9.0) - mean * mean);

            MinColor = mean - AABBScale * stddev;
            MaxColor = mean + AABBScale * stddev;

            FilterColor = SampleColors[4];
            MinColor = min(MinColor, FilterColor);
            MaxColor = max(MaxColor, FilterColor);
        }
        
        //
        //
        //
        //
        inline float4 GetScreenPos(in float2 uv, in float z)
        {
            float x = uv.x * 2.0f - 1.0f;
            float y = (1.0 - uv.y) * 2.0f - 1.0f;
            return float4(x, y, z, 1.0f);
        }
        
        inline float3 ReconstructPosition(in float2 uv, in float z, in float4x4 InvVP)
        {
            float4 position_s = GetScreenPos( uv, z );
            float4 position_v = mul(position_s, InvVP);
            return position_v.xyz / position_v.w;
        }

        float2 cell(float2 ray, float2 cell_count) 
        {
            return floor(ray.xy * cell_count);
        }

        float2 cell_count(float level) 
        {
            return OutputSize / (level == 0.0 ? 1.0 : exp2(level));
        }

        float3 intersect_cell_boundary(float3 pos, float3 dir, float2 cell_id, float2 cell_count, float2 cross_step, float2 cross_offset) 
        {
            float2 cell_size = 1.0 / cell_count;
            float2 planes = cell_id/cell_count + cell_size * cross_step;

            float2 solutions = (planes - pos.xy)/dir.xy;
            float3 intersection_pos = pos + dir * min(solutions.x, solutions.y);

            intersection_pos.xy += (solutions.x < solutions.y) ? float2(cross_offset.x, 0.0) : float2(0.0, cross_offset.y);

            return intersection_pos;
        }

        bool crossed_cell_boundary(float2 cell_id_one, float2 cell_id_two) 
        {
            return (int)cell_id_one.x != (int)cell_id_two.x || (int)cell_id_one.y != (int)cell_id_two.y;
        }

        float minimum_depth_plane(float2 ray, float level, float2 cell_count) 
        {
            return g_ClippingPlanes.x / HiZDepthBuffer.Load(int3(ray.xy * cell_count, level)).r;
        }

        float3 hi_z_trace(float3 p, float3 v) {
         float level = HIZ_START_LEVEL;
         float3 v_z = v/v.z;
         float2 hi_z_size = cell_count(level);
         float3 ray = p;

         float2 cross_step = float2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);
         float2 cross_offset = cross_step * 0.00001;
         cross_step = saturate(cross_step);

         float2 ray_cell = cell(ray.xy, hi_z_size.xy);
         ray = intersect_cell_boundary(ray, v, ray_cell, hi_z_size, cross_step, cross_offset);

         uint iterations = 0;
         while(level >= HIZ_STOP_LEVEL && iterations < MAX_ITERATIONS) {
          float2 current_cell_count = cell_count(level);
          float2 old_cell_id = cell(ray.xy, current_cell_count);

          float min_z = minimum_depth_plane(ray.xy, level, current_cell_count);

          float3 tmp_ray = ray;
          if(v.z > 0) {
           float min_minus_ray = min_z - ray.z;
           tmp_ray = min_minus_ray > 0 ? ray + v_z*min_minus_ray : tmp_ray;
           float2 new_cell_id = cell(tmp_ray.xy, current_cell_count);
           if(crossed_cell_boundary(old_cell_id, new_cell_id)) {
            tmp_ray = intersect_cell_boundary(ray, v, old_cell_id, current_cell_count, cross_step, cross_offset);
            level = min(HIZ_MAX_LEVEL, level + 2.0f);
           }else{
            if(level == 1 && abs(min_minus_ray) > 0.0001) {
             tmp_ray = intersect_cell_boundary(ray, v, old_cell_id, current_cell_count, cross_step, cross_offset);
             level = 2;
            }
           }
          } else if(ray.z < min_z) {
           tmp_ray = intersect_cell_boundary(ray, v, old_cell_id, current_cell_count, cross_step, cross_offset);
           level = min(HIZ_MAX_LEVEL, level + 2.0f);
          }

          ray.xyz = tmp_ray.xyz;
          --level;

          ++iterations;
         }
         return ray;
        }
        
        float3 project_tc(float3 pos, float4x4 mat)
        {
            float4 res = mul(mat, float4(pos, 1));
            res /= res.w;
            return float3(res.xy * float2(0.5, -0.5) + float2(0.5, 0.5), res.z);
        }
        
        float3 ImportanceSampleGGXPdf(float2 Xi, float Roughness, float3 N, out float PDF)
        {
            float a = Roughness * Roughness;
            float Phi = 2 * PI * Xi.x;
            float CosTheta = sqrt((1 - Xi.y) / (1 + (a*a - 1) * Xi.y));
            float SinTheta = sqrt(1 - min(1.0f, CosTheta * CosTheta));
            float3 H;
            H.x = SinTheta * cos(Phi);
            H.y = SinTheta * sin(Phi);
            H.z = CosTheta;
            float3 UpVector = abs(N.z) < 0.999 ? float3(0, 0, 1) : float3(1, 0, 0);
            float3 TangentX = normalize(cross(UpVector, N));
            float3 TangentY = cross(N, TangentX);

            float m2 = a * a;
            float d = (CosTheta * m2 - CosTheta) * CosTheta + 1;
            float D = m2 / (PI*d*d);
             PDF = D * CosTheta;

            // Tangent to world space
            return TangentX * H.x + TangentY * H.y + N * H.z;
        }
        float ComputeRoughnessMaskScale(in float maxRoughness)
        {
            float MaxRoughness = clamp(maxRoughness, 0.01f, 1.0f);
            
            float roughnessMaskScale = -2.0f / MaxRoughness;
            return roughnessMaskScale * 1.0f; // 2.0f & 1.0f
        }

        float GetRoughnessFade(in float roughness, in float maxRoughness)
        {
            float roughnessMaskScale = ComputeRoughnessMaskScale(maxRoughness);
            return min(roughness * roughnessMaskScale + 2, 1.0f);
        }
    }
    
    shader HiZTraceCS {
        uint2 pixelID = uint2( $SV_DispatchThreadId.x, $SV_DispatchThreadId.y );
        
        float depth = g_ClippingPlanes.x / HiZDepthBuffer[pixelID].r;
        float4 thinGbuffer = ThinGBuffer[pixelID];
        
        float2 uv = ( pixelID + 0.5f ) * ( 1.0f / OutputSize );
        
        // Initialize to 0 as some of the code paths might not write to O/P
        RayHitTarget[pixelID] = float4(0, 0, 0, 0);
        MaskTarget[pixelID] = 0.0f;
        
        if ( depth == 0.0f ) return;
      
        float3 P = ReconstructPosition(uv, depth, g_InverseViewProjectionMatrix);
        float roughness = thinGbuffer.a;
        float roughnessFade = GetRoughnessFade(roughness, SSRMaxRoughness);
        
        if ( roughnessFade <= 0.0f ) return;
    
        bool isMirror = ( roughness < 0.1f );
        
        float3 V = normalize( -P );
        float3 normalWorldSpace = DecodeNormals( thinGbuffer.rg );
        float3 N = mul((float3x3)g_ViewMatrix, normalWorldSpace).xyz;
        
        float2 Hash = BlueNoise.SampleLevel(LinearSampler, (uv + HaltonOffset.xy) * OutputSize.xy / float2(BLUE_NOISE_SIZE, BLUE_NOISE_SIZE), 0.0f).rg * 2.0 - 1.0;
        
        float PDF = 0.0f;
        float3 H = ( isMirror ) ? N : ImportanceSampleGGXPdf( HaltonOffset, roughness, N, PDF );
        float3 L = 2 * dot(V, H) * H - V;
        float3 R = L;
        float RoN = dot( R, N );

        if ( RoN < 0 ) R = normalize( R + N );

        float3 posr = P + normalize( R );
        float3 pss = float3(uv, depth);
        float4 pcs = mul(g_ProjectionMatrix, float4(posr,1));
        float3 pss_ = pcs.xyz / pcs.w;
        pss_.xy = pss_.xy * float2(0.5, -0.5) + float2(0.5, 0.5); 
        
        float3 rayTrace = hi_z_trace(pss, (pss_- pss));
        
        RayHitTarget[$SV_DispatchThreadId.xy] = float4(rayTrace, PDF);
    }

    shader ResolveCS {      
        uint2 pixelID = uint2( $SV_DispatchThreadId.x, $SV_DispatchThreadId.y );
        
        float depth = g_ClippingPlanes.x / HiZDepthBuffer[pixelID].r;
        
        if (depth == 0.0f) return;
      
        float4 thinGbuffer = ThinGBuffer[pixelID];
        float roughness = thinGbuffer.a;
        float roughnessFade = GetRoughnessFade(roughness, SSRMaxRoughness);
        
        if (roughnessFade <= 0.0f) return;
    
        float4 dist = RayTraceBuffer[pixelID];
        
        float2 uv = ( pixelID + 0.5f ) * ( 1.0f / OutputSize );
        
        float3 P = ReconstructPosition(uv, depth, g_InverseViewProjectionMatrix);

		float3 v = -normalize(g_WorldPosition - P);
        float3 normal = DecodeNormals( thinGbuffer.rg );
		float3 r = reflect(v, normal);

		float2 tc = project_tc(P + dist.x * r, g_ViewProjectionMatrix);
        
        ResolvedOutput[pixelID] = ColorBuffer.SampleLevel( LinearSampler, tc, 0.0f );
    }
    
    pass HiZTrace {
        compute = HiZTraceCS;
        dispatch = { 16, 16, 1 };
    } 
    
    pass ResolveTrace {
        compute = ResolveCS;
        dispatch = { 16, 16, 1 };
    }
}