lib PrimitiveLighting {
    properties {
        cflag       WriteVelocity = false;
        cflag       MaterialEditor = false;
        float       StartVector;
        float       VectorPerInstance;
    }
    
    resources {   
        Texture2D OutputRenderTarget {
            swizzle = float4;
        }
        
        Texture2D OutputVelocity {
            swizzle = float2;
        }
        
        Texture2D OutputDepthTarget {
            swizzle = float4;
        }
        
        Buffer InstanceVectorBuffer {
            swizzle = float4;
        }
        
        sampler TextureSampler {
            format = BilinearClampEdge;
        }
        
        RWByteAddressBuffer PickingBuffer {
            format = uint;
        }
        
        // Injected at Material compile-time. DO NOT REMOVE.
        DUSK_LAYERS_RESOURCES;
    }
    
    shared {
        #include <Material.hlsli>
        
        #ifdef $MaterialEditor
        
        // Injected at Material compile-time. Bakes texture sampling for interactive material
        // edition.
        float4 FetchBakedTextureSampler( float2 uvMapTexCoords, int layerIndex, int attributeIndex, float2 scale, float2 offset )
        {
            DUSK_BAKED_TEXTURE_FETCH;
            
            // Dummy value to avoid compiler complains if the active material has no texture.
            return float4( 1, 0, 1, 1 );
        }

        #include <MaterialEditor.hlsli>
        #endif
        
        float4x4 GetInstanceModelMatrix( Buffer instanceVectorBuffer, const uint instanceIdx )
        {
            uint modelMatrixVectorOffset = StartVector + instanceIdx * VectorPerInstance;
            
            float4 r0 = instanceVectorBuffer.Load( modelMatrixVectorOffset + 0 );
            float4 r1 = instanceVectorBuffer.Load( modelMatrixVectorOffset + 1 );
            float4 r2 = instanceVectorBuffer.Load( modelMatrixVectorOffset + 2 );
            float4 r3 = instanceVectorBuffer.Load( modelMatrixVectorOffset + 3 );
            
            return float4x4( r0, r1, r2, r3 );
        }
                    
        float2 ComputeScreenSpaceVelocity( float4 previousPosition, float4 position )
        {
            float2 screenSizeWithSSAA = g_ScreenSize * g_ImageQuality;
            
            float2 prevPositionSS = ( previousPosition.xy / previousPosition.w ) * float2( 0.5f, -0.5f ) + 0.5f;
            prevPositionSS *= screenSizeWithSSAA;
           
            float2 Velocity = ( position.xy - prevPositionSS );
            Velocity -= g_CameraJitteringOffset;
            Velocity /= screenSizeWithSSAA;
            
            return Velocity;
        }
        
        void UpdatePickingBuffer(uint2 pos, uint identity, float z, float opacity) 
        {
            static const float OpacityThreshold = 0.5f;
            if (opacity < OpacityThreshold) {
                return;
            }
            
            if (pos.x != g_CursorPosition.x || pos.y != g_CursorPosition.y) {
                return;
            }
            
            uint d = asuint(z);
            uint current_d_or_locked = 0;
            do {
                if (d >= PickingBuffer.Load(0)) {
                    return;
                }
                
                PickingBuffer.InterlockedMin(0, d, current_d_or_locked);
                if (d < (int)current_d_or_locked) {
                    uint last_d = 0;
                    
                    PickingBuffer.InterlockedCompareExchange(0, d, asuint(-(int)d), last_d);
                    
                    if (last_d == d) {
                        PickingBuffer.Store2(4, identity);
                        uint dummy;
                        PickingBuffer.InterlockedExchange(0, d, dummy);
                    }
                }
            } while((int)current_d_or_locked < 0);
        }
        
        float3 GetDirectionalLightIlluminance( in DirectionalLightGPU light, in float3 R, in float3 N, inout float3 L )
        {
            float r = sin( light.AngularRadius );
            float d = cos( light.AngularRadius );

            float DoR = dot( light.NormalizedDirection, R );
            float3 S = R - DoR * light.NormalizedDirection;

            L = ( DoR < d ) ? normalize( d * light.NormalizedDirection + normalize( S ) * r ) : R;

            float illuminance = light.IlluminanceInLux * saturate( dot( N, light.NormalizedDirection ) );

            // Add shadow
            // We assume the surface is lit if not covered by the shadow map
            float3 shadowVisibility = 1.0f;
            float3 surfaceTransmittance = float3( 0, 0, 0 );

            // Get Sun Irradiance
            float3 lightIlluminance = ( light.ColorLinearSpace * illuminance * shadowVisibility.rgb );
            
            return illuminance + ( lightIlluminance * surfaceTransmittance );
        }
        
        // Injected at Material compile-time. DO NOT REMOVE.
        DUSK_LAYERS_FUNCTIONS;
    }
    
    shader PrimitiveVS {
        float4x4 ModelMatrix = GetInstanceModelMatrix( InstanceVectorBuffer, $SV_InstanceID );
        float4 positionWS = mul( float4( $POSITION.xyz, 1.0f ), ModelMatrix );
        
        $TEXCOORD0 = $TEXCOORD;
        $POSITION0 = positionWS;
        $NORMAL0 = normalize( mul( ModelMatrix, float4( $NORMAL.xyz, 0.0f ) ) );
        $POSITION1 = mul( g_PreviousViewProjectionMatrix, float4( positionWS.xyz, 1.0f ) );
        $SV_POSITION =  mul( g_ViewProjectionMatrix, float4( positionWS.xyz, 1.0f ) );
    }
    
    shader PrimitivePS {
        float2 UvMap0 = $TEXCOORD0;
        
#ifdef $MaterialEditor
        Material BlendedMaterial = FetchMaterialAttributes( UvMap0 );
#else
        // Injected at Material compile-time. DO NOT REMOVE.
        // Return a ready to use material named BlendedMaterial.
        DUSK_LAYERS_GET;
#endif
        
        float3 V = normalize( g_WorldPosition - $POSITION0.xyz );
        float3 N = normalize( $NORMAL0.xyz );
        float3 R = reflect( -V, N );
        
        float4 LightContribution = float4( 0, 0, 0, 1 );
        
        // Add explicit sun/moon light contribution
        float3 L;
        float3 dirLightIlluminance = GetDirectionalLightIlluminance( g_DirectionalLight, R, N, L );        
        LightContribution.rgb = BRDF_Default( L, V, N, BlendedMaterial ) * dirLightIlluminance;
        
        $SV_TARGET0 = LightContribution;
        
#ifdef $WriteVelocity
        $SV_TARGET1 = ComputeScreenSpaceVelocity( $POSITION1, $SV_POSITION ).rgrg;      
#endif

#ifdef $DoPickingCheck
        UpdatePickingBuffer( (uint2)$SV_POSITION.xy, 0, $SV_POSITION.z, 1.0f );
#endif
    }
    
    pass LightPass {
        vertex = PrimitiveVS;
        pixel = PrimitivePS;
        WriteVelocity = true;
        UseInstancing = false;
        rendertargets = { OutputRenderTarget, OutputVelocity };
        depthStencil = OutputDepthTarget;
    }
    
    pass LightPassEd {
        vertex = PrimitiveVS;
        pixel = PrimitivePS;
        MaterialEditor = true;
        WriteVelocity = true;
        UseInstancing = false;
        rendertargets = { OutputRenderTarget, OutputVelocity };
        depthStencil = OutputDepthTarget;
    }
}
